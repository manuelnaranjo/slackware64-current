#!/bin/sh
# GCC package build script (written by volkerdi@slackware.com)
#
# Copyright 2003, 2004  Slackware Linux, Inc., Concord, California, USA
# Copyright 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012  Patrick J. Volkerding, Sebeka, MN, USA
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

# Modified 2011 by Eric Hameleers <alien at slackware.com> for OpenJDK.

# Some notes, Fri May 16 12:31:32 PDT 2003:
#
# Why i486 and not i386?  Because the shared C++ libraries in gcc-3.2.x will
# require 486 opcodes even when a 386 target is used (so we already weren't
# compatible with the i386 for Slackware 9.0, didn't notice, and nobody
# complained :-).  gcc-3.3 fixes this issue and allows you to build a 386
# compiler, but the fix is done in a way that produces binaries that are not
# compatible with gcc-3.2.x compiled binaries.  To retain compatibility with
# Slackware 9.0, we'll have to use i486 (or better) as the compiler target
# for gcc-3.3.
#
# It's time to say goodbye to i386 support in Slackware.  I've surveyed 386
# usage online, and the most common thing I see people say when someone asks
# about running Linux on a 386 is to "run Slackware", but then they also 
# usually go on to say "be sure to get an OLD version, like 4.0, before glibc,
# because it'll be more efficient."  Now, if that's the general advice, then
# I see no reason to continue 386 support in the latest Slackware (and indeed
# it's no longer easily possible).

PKGNAM=gcc
VERSION=${VERSION:-$(echo $PKGNAM-*.tar.xz | rev | cut -f 3- -d . | cut -f 1 -d - | rev)}
BUILD=${BUILD:-1}

# How many jobs to run in parallel:
NUMJOBS=" -j 7 "

# Automatically determine the architecture we're building on:
if [ -z "$ARCH" ]; then
  case "$(uname -m)" in
    i?86) ARCH=i486 ;;
    arm*) readelf /usr/bin/file -A | egrep -q "Tag_CPU.*[4,5]" && ARCH=arm || ARCH=armv7lh ;;
    # Unless $ARCH is already set, use uname -m for all other archs:
    *) ARCH=$(uname -m) ;;
  esac
  export ARCH
fi

if [ "$ARCH" = "i486" -o "$ARCH" = "i586" -o "$ARCH" = "i686" ]; then
  SLKCFLAGS="-O2 -march=$ARCH -mtune=i686"
  LIBDIRSUFFIX=""
  LIB_ARCH=i386
elif [ "$ARCH" = "s390" ]; then
  SLKCFLAGS="-O2"
  LIBDIRSUFFIX=""
  LIB_ARCH=s390
elif [ "$ARCH" = "x86_64" ]; then
  SLKCFLAGS="-O2 -fPIC"
  LIBDIRSUFFIX="64"
  LIB_ARCH=amd64
elif [ "$ARCH" = "armv7hl" ]; then
  SLKCFLAGS="-O3 -march=armv7-a -mfpu=vfpv3-d16"
  LIBDIRSUFFIX=""
  LIB_ARCH=armv7hl
else
  SLKCFLAGS="-O2"
  LIBDIRSUFFIX=""
  LIB_ARCH=$ARCH
fi

case "$ARCH" in
    arm*) TARGET=$ARCH-slackware-linux-gnueabi ;;
    *)    TARGET=$ARCH-slackware-linux ;;
esac

CWD=$(pwd)
# Temporary build location.  This should *NOT* be a directory
# path a non-root user could create later...
TMP=${TMP:-"/gcc-$(mcookie)"}

# This is the main DESTDIR target:
PKG_GCC=$TMP/package-gcc
# These are the directories to build other packages in:
PKG_GCC_GPP=$TMP/package-gcc-g++
PKG_GCC_GFORTRAN=$TMP/package-gcc-gfortran
PKG_GCC_GNAT=$TMP/package-gcc-gnat
PKG_GCC_JAVA=$TMP/package-gcc-java
PKG_GCC_OBJC=$TMP/package-gcc-objc
# PKG_GCC_GPP_GCH=$TMP/package-gcc-g++-gch
PKG_GCC_GO=$TMP/package-gcc-go

ALL_PKGS="${PKG_GCC} ${PKG_GPP} ${PKG_GFORTRAN} ${PKG_GNAT} ${PKG_JAVA} ${PKG_OBJC} ${PKG_GO}"
ALL_LANGS="gcc gcc-g++ gcc-gfortran gcc-gnat gcc-java gcc-objc gcc-go"
ALL_LIBS="libgfortran libada libffi libjava libmudflap libgomp libobjc libstdc++-v3"
ALL_ELEMENTS="main ${ALL_LANGS} ${ALL_LIBS}"


# pkg_of_element "${ELEMENT}"
# Given an "element" (which is a member of ${ALL_ELEMENTS}), return its
# destination package
pkg_of_element() {
  case "$1" in
    gcc | libmudflap | libgomp | main) echo "${PKG_GCC}";;
    gcc-g++ | libstdc++-v3) echo "${PKG_GCC_GPP}" ;;
    gcc-gfortran | libgfortran) echo "${PKG_GCC_GFORTRAN}" ;;
    gcc-gnat | libada) echo "${PKG_GCC_GNAT}" ;;
    gcc-java | libffi | libjava) echo "${PKG_GCC_JAVA}" ;;
    gcc-objc | libobjc) echo "${PKG_GCC_OBJC}" ;;
    # gcc-g++-gch) echo "${PKG_GCC_GPP_GCH}" ;;
    gcc-go) echo "${PKG_GCC_GO}" ;;
  esac
}

# doc_dir_of_element "${ELEMENT}"
# Given an "element" (which is a member of ${ALL_ELEMENTS}", return the path
# to the corresponding documentation inside the build directory
doc_dir_of_element() {
  case "$1" in
    main) echo "." ;;
    gcc) echo "gcc" ;;
    gcc-g++) echo "NONE" ;;
    gcc-gfortran) echo "gcc/fortran" ;;
    gcc-gnat) echo "gcc/ada" ;;
    gcc-java) echo "gcc/java" ;;
    gcc-objc | libobjc) echo "gcc/objc" ;;
    # gcc-g++-gch) echo "gcc/g++-gch" ;;
    gcc-go) echo "gcc/go" ;;
    lib*) echo "$1" ;;
    # I would have liked to write the following but it's not valid syntax:
    # lib{omp,mudflap,java,ffi,ada,gfortran,stdc++-v3,objc}) echo "$1" ;;
  esac
}

# If there's a new file, installing at least part of the recent history
# is useful, but don't let it get totally out of control:
install_with_length_limit() {
  FILE="$1"
  DOCSDIR="$2"
  if [ -r "$FILE" ]; then
    cat "$FILE" | head -n 1000 > "${DOCSDIR}/${FILE}"
    touch -r "$FILE" "${DOCSDIR}/${FILE}"
  fi
}

# move_from_pkg_gcc "${GLOB}"
# When issuing "make install", everything gets installed in a single directory
# and then moved to the corresponding package. This function moves files
# matching a glob (given as $1) from ${PKG_GCC} to the current package
# directory.
move_from_pkg_gcc() {
  SRC_DIR="$(dirname "$1")"
  mkdir -p "${SRC_DIR}"
  DEST_DIR="$(cd "${SRC_DIR}" && pwd)"
  (cd "${PKG_GCC}" && eval mv $* "${DEST_DIR}")
}

# symlink_to "${LINK_TARGET}" file1 file2 file3
# A common operation is to symlink several files to one in order to be able to
# use several names for it: gcc, x86_64-slackware-linux-gcc, cc, ...
symlink_to() {
  LINK_TARGET="$1"
  shift
  for bin in $*; do
    ln -sf "${LINK_TARGET}" "${bin}"
  done
}

# compress_info_files ${PREFIX}
# Compress info files in ${PREFIX}/usr/info if any.
compress_info_files() {
  [ -d $1/usr/info ] && ( cd $1/usr/info && rm -f dir && gzip -9 *)
}

# Clear the build locations:
if [ -d $TMP ]; then
  rm -rf $TMP
fi
for PKG in ${ALL_PKGS}; do
  mkdir -p ${PKG}/usr/doc/gcc-${VERSION}
done

# Insert package descriptions:
for LANG in ${ALL_LANGS}; do
  PKG="$(pkg_of_element "${LANG}")"
  if [ -e "slack-desc.${LANG}" ]; then
    mkdir -p ${PKG}/install
    cat $CWD/slack-desc.${LANG} > $PKG/install/slack-desc
  fi
done

cd $TMP
tar xvf $CWD/gcc-$VERSION.tar.?z*

# Copy ecj.jar into the TLD of the source. Needed for java compiler.
# This can be retrieved from ftp://sourceware.org/pub/java
cp $CWD/ecj-4.5.jar gcc-$VERSION/ecj.jar

# Use an antlr runtime to compile javadoc.
# The runtime can be obtained from:
#https://oss.sonatype.org/content/repositories/releases/org/antlr/antlr-runtime/
ANTLJAR=$(echo $CWD/antlr-*.jar | tail -1)

# install docs
( cd gcc-$VERSION
  # Smite the fixincludes:
  zcat $CWD/gcc-no_fixincludes.diff.gz | patch -p1 --verbose --backup --suffix=.orig || exit 1
  # Fix perms/owners
  chown -R root:root .
  find . -perm 777 -o -perm 775 -o -perm 754 -exec chmod 755 {} \;
  find . -perm 664 -exec chmod 644 {} \;

  for ELEMENT in ${ALL_ELEMENTS}; do
    DOC_DIR="$(doc_dir_of_element "${ELEMENT}")"
    if [ "${DOC_DIR}" = "NONE" ]; then
      continue
    fi
    PKG="$(pkg_of_element "${ELEMENT}")"
    PKG_DOC_DIR="${PKG}/usr/doc/gcc-${VERSION}/${DOC_DIR}"
    unset FULL_FILES
    LIMITED_FILES=ChangeLog
    case "${ELEMENT}" in
      main)
        FULL_FILES="COPYING* ChangeLog* INSTALL LAST_UPDATED MAINTAINERS README*"
        LIMITED_FILES="${LIMITED_FILES} NEWS"
        ;;
      gcc) FULL_FILES="ABOUT* COPYING* DATESTAMP DEV-PHASE LANG* ONEWS README*" ;;
      gcc-gnat | gcc-java) FULL_FILES="ChangeLog.tree-ssa" ;;
      gcc-go) FULL_FILES="README* gofrontend/{LICENSE,PATENTS,README}" ;;
      libffi) FULL_FILES="ChangeLog.libgcj ChangeLog.v1 LICENSE* README*" ;;
      libjava) FULL_FILES="COPYING* HACKING LIBGCJ_LICENSE NEWS README* THANKS" ;;
      libstdc++-v3) FULL_FILES="README* doc/html/faq.html" ;;
    esac
    mkdir -p "${PKG_DOC_DIR}"
    (cd ${DOC_DIR}
      if [ -n "${FULL_FILES}" ]; then
        eval cp -a "${FULL_FILES}" "${PKG_DOC_DIR}"
      fi
      for FILE in $(eval echo "${LIMITED_FILES}"); do
        install_with_length_limit "${FILE}" "${PKG_DOC_DIR}"
      done)
  done
)

# Add fastjar to the gcc-java package:
( cd $TMP
  FASTJARVER=$(echo $CWD/fastjar-*.tar.xz | rev | cut -f 3- -d . | cut -f 1 -d - | rev)
  echo
  echo "Building fastjar-$FASTJARVER first"
  echo
  rm -rf fastjar-$FASTJARVER
  tar xvf $CWD/fastjar-$FASTJARVER.tar.xz || exit 1
  cd fastjar-$FASTJARVER || exit
  chown -R root:root .
  find . \
    \( -perm 777 -o -perm 775 -o -perm 711 -o -perm 555 -o -perm 511 \) \
    -exec chmod 755 {} \; -o \
    \( -perm 666 -o -perm 664 -o -perm 600 -o -perm 444 -o -perm 440 -o -perm 400 \) \
    -exec chmod 644 {} \;
  for patch in $CWD/fastjar-patches/*.gz ; do
    zcat $patch | patch -p1 --verbose || exit 1
  done
  CFLAGS="$SLKCFLAGS" \
  CXXFLAGS="$SLKCFLAGS" \
  ./configure \
     --prefix=/usr \
     --libdir=/usr/lib$LIBDIRSUFFIX \
     --mandir=/usr/man \
     --infodir=/usr/info \
     --build=$TARGET
  make $NUMJOBS || exit 1
  make install DESTDIR=${PKG_GCC_JAVA} || exit 1
  mkdir -p ${PKG_GCC_JAVA}/usr/doc/fastjar-$FASTJARVER
  cp -a \
    AUTHORS CHANGES COPYING* INSTALL NEWS README* TODO \
    ${PKG_GCC_JAVA}/usr/doc/fastjar-$FASTJARVER
  install_with_length_limit "ChangeLog" "${PKG_GCC_JAVA}/usr/doc/fastjar-${FASTJARVER}"
  find ${PKG_GCC_JAVA} -type f | xargs file | grep -e "executable" -e "shared object" | grep ELF \
    | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null
  # Compress and if needed symlink the man pages:
  if [ -d ${PKG_GCC_JAVA}/usr/man ]; then
    ( cd ${PKG_GCC_JAVA}/usr/man
      for manpagedir in $(find . -type d -name "man*") ; do
        ( cd $manpagedir
          for eachpage in $( find . -type l -maxdepth 1) ; do
            ln -s $( readlink $eachpage ).gz $eachpage.gz
            rm $eachpage
          done
          gzip -9 *.?
        )
      done
    )
  fi
  compress_info_files ${PKG_GCC_JAVA}
  echo
) || exit 1

# build gcc
( mkdir gcc.build.lnx;
  cd gcc.build.lnx;

  # If enough people need "treelang" support for it may be considered.
  #  --enable-languages=ada,c,c++,fortran,java,objc,treelang
  # I think it is incorrect to include this option (as it will end up set
  # to i486 on x86 platforms), and we want to tune the binary structure
  # for i686, as that is where almost all of the optimization speedups
  # are to be found.
  # Correct me if my take on this is wrong.
  #  --with-cpu=$ARCH 
 
  if [ "$ARCH" != "x86_64" ]; then
    GCC_ARCHOPTS="--with-arch=$ARCH"
  else
    GCC_ARCHOPTS="--disable-multilib"
  fi
 
  CFLAGS="$SLKCFLAGS" \
  CXXFLAGS="$SLKCFLAGS" \
  ../gcc-$VERSION/configure --prefix=/usr \
     --libdir=/usr/lib$LIBDIRSUFFIX \
     --mandir=/usr/man \
     --infodir=/usr/info \
     --enable-shared \
     --enable-bootstrap \
     --enable-languages=ada,c,c++,fortran,go,java,lto,objc \
     --enable-threads=posix \
     --enable-checking=release \
     --enable-objc-gc \
     --with-system-zlib \
     --with-python-dir=/lib$LIBDIRSUFFIX/python2.6/site-packages \
     --disable-libunwind-exceptions \
     --enable-__cxa_atexit \
     --enable-libssp \
     --enable-lto \
     --with-gnu-ld \
     --verbose \
     --enable-java-home \
     --with-java-home=/usr/lib$LIBDIRSUFFIX/jvm/jre \
     --with-jvm-root-dir=/usr/lib$LIBDIRSUFFIX/jvm \
     --with-jvm-jar-dir=/usr/lib$LIBDIRSUFFIX/jvm/jvm-exports \
     --with-arch-directory=$LIB_ARCH \
     --with-antlr-jar=$ANTLJAR \
     --enable-java-awt=gtk \
     --disable-gtktest \
     $GCC_ARCHOPTS \
     --target=${TARGET} \
     --build=${TARGET} \
     --host=${TARGET} || exit 1

  # Start the build:

  # Include all debugging info (for now):
  make $NUMJOBS bootstrap

  ( cd gcc
    make $NUMJOBS gnatlib GNATLIBCFLAGS="$SLKCFLAGS"
    # This wants a shared -laddr2line?
    #make gnatlib-shared
    
    CFLAGS="$SLKCFLAGS" \
    CXXFLAGS="$SLKCFLAGS" \
    make $NUMJOBS gnattools
  )
  make info

  # Set GCCCHECK=something to run the tests
  if [ ! -z $GCCCHECK ]; then
    make $NUMJOBS check
  fi

  make install DESTDIR=$PKG_GCC

  # KLUDGE ALERT
  # These *gdb.py files are causing ldconfig to complain, so they are going
  # to be REMOVED for now...  at some point, they might be moved somewhere
  # else, in which case things should Just Work(tm).  Keep an eye on it.
  rm -f $PKG_GCC/usr/lib${LIBDIRSUFFIX}/*gdb.py

  # Be sure the "specs" file is installed.
  if [ ! -r $PKG_GCC/usr/lib${LIBDIRSUFFIX}/gcc/${TARGET}/${VERSION}/specs ]; then
    cat stage1-gcc/specs > $PKG_GCC/usr/lib${LIBDIRSUFFIX}/gcc/${TARGET}/${VERSION}/specs
  fi

  # Make our 64bit gcc look for 32bit gcc binaries in ./32 subdirectory:
  if [ "$ARCH" = "x86_64" ]; then
    sed -i 's#;.\(:../lib !m64 m32;\)$#;32\1#' \
      $PKG_GCC/usr/lib${LIBDIRSUFFIX}/gcc/${TARGET}/${VERSION}/specs
  fi

  #  make ada.install-common DESTDIR=$PKG_GCC
  #  make install-gnatlib DESTDIR=$PKG_GCC
  make -i install-info DESTDIR=$PKG_GCC

  chmod 755 $PKG_GCC/usr/lib${LIBDIRSUFFIX}/libgcc_s.so.1

  # The (huge) static GNU java libraries are not packaged.  In nearly all
  # cases one or more dependencies will not be available as static anyway.
  rm -f $PKG_GCC/usr/lib${LIBDIRSUFFIX}/libgcj.a
  rm -f $PKG_GCC/usr/lib${LIBDIRSUFFIX}/libgcj-tools.a

  # This is provided by binutils, so delete it here:
  rm -f $PKG_GCC/usr/lib${LIBDIRSUFFIX}/libiberty.a
  rm -f $PKG_GCC/usr/lib/libiberty.a # catch-all

  # Fix stuff up:
  compress_info_files ${PKG_GCC}
  ( cd $PKG_GCC
    # *not* ${LIBDIRSUFFIX}
    mkdir -p lib
    ln -sf /usr/bin/cpp lib/cpp
  )

  ( cd $PKG_GCC/usr/bin
    mv gcc gcc-$VERSION
    mv g++ g++-gcc-$VERSION
    mv ${TARGET}-gfortran gfortran-gcc-$VERSION
    for bin in gcc-${VERSION} gcc-ar gcc-nm gcc-ranlib gcj gcjh; do
      ln -sf ${bin} ${TARGET}-${bin}
    done
    symlink_to "gcc-${VERSION}" gcc ${TARGET}-gcc cc
    symlink_to "g++-gcc-${VERSION}" g++ c++ ${TARGET}-{c++,g++}
    symlink_to "gfortran-gcc-${VERSION}" gfortran fortran ${TARGET}-{gfortran,gfortran-${VERSION},g95,g77} {f,g}{95,77}
  )

  ( cd $PKG_GCC/usr/man
    gzip -9 */*
    cd man1
    ln -sf g++.1.gz c++.1.gz
    ln -sf gcc.1.gz cc.1.gz
  )  

  ## build the txz package
  #(
  #  cd $PKG_GCC;
  #  makepkg -l y -c n $TMP/gcc-$VERSION-$ARCH-$BUILD.txz
  #)
  # keep a log
) 2>&1 | tee $TMP/gcc.build.log

# OK, time to split the big package where needed:

# gcc-g++:
( cd $PKG_GCC_GPP
  move_from_pkg_gcc "usr/bin/*++*"
  move_from_pkg_gcc "usr/include/c++"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/*++*"
  move_from_pkg_gcc "usr/libexec/gcc/$TARGET/$VERSION/cc1plus"
  move_from_pkg_gcc "usr/man/man1/*++*"
)

# gcc-gfortran:
( cd $PKG_GCC_GFORTRAN
  move_from_pkg_gcc "usr/bin/{*gfortran*,*95*,*77*}"
  move_from_pkg_gcc "usr/info/gfortran*"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/gcc/$TARGET/$VERSION/{finclude,libgfortran*}"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/libgfortran*"
  move_from_pkg_gcc "usr/libexec/gcc/$TARGET/$VERSION/f951"
  move_from_pkg_gcc "usr/man/man1/gfortran*"
)

# gcc-gnat:
# First, relocate usr/bin/gnative2ascii to the gcc-java package so it
# isn't matched and accidentally put in gcc-gnat:
mkdir -p $PKG_GCC_JAVA/usr/bin
mv $PKG_GCC/usr/bin/gnative2ascii $PKG_GCC_JAVA/usr/bin
# Now make the gcc-gnat package tree:
( cd $PKG_GCC_GNAT
  move_from_pkg_gcc "usr/bin/gnat*"
  move_from_pkg_gcc "usr/info/gnat*"
  move_from_pkg_gcc "usr/libexec/gcc/$TARGET/$VERSION/gnat1"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/gcc/$TARGET/$VERSION/ada{include,lib}"
)

# gcc-java:
( cd $PKG_GCC_JAVA
  # used to mv fastjar too
  move_from_pkg_gcc "usr/bin/{aot-compile,gappletviewer,gc-analyze,*gcj*,gij,gjar,gjarsigner,gkeytool,grmid,grmic,grmiregistry,gserialver,gtnameserv,gjavah,gorbd,jcf-dump,jv-*}"
  # Move some Java only C++ headers from the C++ package:
  (DIR="usr/include/c++/$VERSION"; mkdir -p ${DIR} && mv $PKG_GCC_GPP/$DIR/{gcj,gnu,java,javax,org,sun} $DIR)
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/gcc/$TARGET/$VERSION/include/{jawt,ffi,ffitarget,jawt_md,jni,jni_md,jvmpi}.h"
  # aot-compile Python plugins:
  if [ ! -d $PKG_GCC/usr/lib${LIBDIRSUFFIX}/python2.6 ]; then
    echo "NO $PKG_GCC/usr/lib${LIBDIRSUFFIX}/python2.6 !"
    exit 1
  fi
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/python2.6"
  move_from_pkg_gcc "usr/info/gcj.*"
  # move_from_pkg_gcc usr/info/fastjar.*"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/{libffi*,logging.properties,gcj*,libgcj*,libgij*,security}"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/pkgconfig/libgcj*.pc"
  rmdir $PKG_GCC/usr/lib${LIBDIRSUFFIX}/pkgconfig 2> /dev/null
  move_from_pkg_gcc "usr/libexec/gcc/$TARGET/$VERSION/{jc1,ecj1,jvgenmain}"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/gcc/$TARGET/$VERSION/include/gcj"
  move_from_pkg_gcc "usr/man/man1/{aot-compile,gappletviewer,gc-analyze,gcj,gcjh,gcj-dbtool,gij,gjar,gjarsigner,gjavah,gjdoc,gkeytool,gnative2ascii,gorbd,grmic,grmid,grmiregistry,gserialver,gtnameserv,jcf-dump,jv-convert,rebuild-gcj-db}.1.gz"
  move_from_pkg_gcc "usr/share/java"
  # The ecj wrapper script:
  cat $CWD/ecj.sh | sed -e "s,@JAVADIR@,/usr/share/java," > usr/bin/ecj
  chmod 755 usr/bin/ecj
  # The JAVA_HOME compatibility links.
  # Caution: non-multilib arch-independent stuff! No lib64 here.
  move_from_pkg_gcc usr/lib${LIBDIRSUFFIX}/jvm*
  # And add the missing javac symlink:
  ln -s ../../../bin/ecj usr/lib$LIBDIRSUFFIX/jvm/bin/javac
)

# gcc-objc:
( cd $PKG_GCC_OBJC
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/libobjc*"
  move_from_pkg_gcc "usr/libexec/gcc/$TARGET/$VERSION/cc1obj"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/gcc/$TARGET/$VERSION/include/objc"
)

## NOTE: Thought about this, because the precompiled headers are so large.
## Probably easier to keep everything together, though.
## gcc-g++-gch (precompiled c++ headers)
#( cd $PKG_GCC_GPP_GCH
#  mkdir -p usr/include/c++/$VERSION/$TARGET/bits
#  mv $PKG_GPP/usr/include/c++/$VERSION/$TARGET/bits/stdc++.h.gch usr/include/c++/$VERSION/$TARGET/bits
#)

# gcc-go:
( cd $PKG_GCC_GO
  move_from_pkg_gcc "usr/bin/*gccgo*"
  move_from_pkg_gcc "usr/libexec/gcc/$TARGET/$VERSION/go1"
  move_from_pkg_gcc "usr/info/gccgo.info.gz"
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/{go,libgo.la,libgo.so.0.*,libgobegin.a}"
  (cd usr/lib${LIBDIRSUFFIX} && [ -e libgo.la -a -e libgo.so.0.* -a -e libgobegin.a ]) || exit 1
  # Ordinarily Slackware does not package static libraries, but in this case
  # it is useful for deploying compiled binaries on machines that do not yet
  # have libgo.so.0.0.0.
  move_from_pkg_gcc "usr/lib${LIBDIRSUFFIX}/libgo.a"
  move_from_pkg_gcc "usr/man/man1/gccgo.1.gz"
) || exit 1

# Filter all .la files (thanks much to Mark Post for the sed script):
find $TMP -type f -name "*.la" | xargs sed -i -e 's%-L/gcc-[[:graph:]]* % %g'

## Strip bloated binaries and libraries:
find ${ALL_PKGS} -type f -name "lib*\.so*" -exec strip --strip-unneeded "{}" \;
find ${ALL_PKGS} -type f -name "lib*\.a" -exec strip -g "{}" \;
strip --strip-unneeded usr/bin/* 2> /dev/null
find ${ALL_PKGS} -type f | xargs file | grep "executable" | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null
find ${ALL_PKGS} -type f | xargs file | grep "shared object" | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null

for LANG in ${ALL_LANGS}; do
  ( cd "$(pkg_of_element "${LANG}")"
    makepkg -l y -c n $TMP/${LANG}-${VERSION}-${ARCH}-${BUILD}.txz )
done

echo
echo "Slackware GCC package build complete!"
echo

